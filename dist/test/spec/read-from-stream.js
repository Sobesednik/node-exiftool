'use strict';

require('source-map-support/register');

var assert = require('assert');
var context = require('exiftool-context');
var fs = require('fs');
var makepromise = require('makepromise');
var exiftool = require('../../src/');
var executeWithRs = require('../../src/execute-with-rs');

context.globalExiftoolConstructor = exiftool.ExiftoolProcess;

var readFromStreamTestSuite = {
    context: context,
    'should read metadata from a read stream': function shouldReadMetadataFromAReadStream(ctx) {
        ctx.create();
        return ctx.ep.open().then(function () {
            var rs = fs.createReadStream(ctx.jpegFile);
            return ctx.ep.readMetadata(rs);
        }).then(function (res) {
            assert(Array.isArray(res.data));
            assert(res.data.length > 0);
            return ctx.assertJpegMetadata(res.data[0]);
        });
    }
};

function assertDoesNotExist(file) {
    return makepromise(fs.stat, [file]).then(function () {
        throw new Error('should have thrown ENOENT error');
    }, function (err) {
        if (!/ENOENT/.test(err.message)) {
            throw err;
        }
    });
}
function assertExists(file) {
    return makepromise(fs.stat, [file]).then(function () {});
}

var readFromRsTestSuite = {
    context: context,
    'should reject if non-readable passed': function shouldRejectIfNonReadablePassed() {
        return executeWithRs('string', null, function () {}).then(function () {
            throw new Error('should have thrown an error');
        }, function (err) {
            assert.equal(err.message, 'Please pass a readable stream');
        });
    },
    'should reject if executeCommand is not a function': function shouldRejectIfExecuteCommandIsNotAFunction(ctx) {
        var rs = fs.createReadStream(ctx.jpegFile);
        return executeWithRs(rs).then(function () {
            throw new Error('should have thrown an error');
        }, function (err) {
            assert.equal(err.message, 'executeCommand must be a function');
        });
    },
    'should read from a rs': function shouldReadFromARs(ctx) {
        ctx.create();
        return ctx.ep.open().then(function () {
            var rs = fs.createReadStream(ctx.jpegFile);
            var executeCommand = ctx.ep._executeCommand.bind(ctx.ep);
            return executeWithRs(rs, null, executeCommand);
        }).then(function (res) {
            assert(Array.isArray(res.data));
            assert(res.data.length > 0);
            return ctx.assertJpegMetadata(res.data[0]);
        });
    },
    'should return execute function result': function shouldReturnExecuteFunctionResult(ctx) {
        var rs = fs.createReadStream(ctx.jpegFile);
        var result = [{ some: 'metadata' }, null];
        var executeCommand = function executeCommand() {
            return result;
        };
        return executeWithRs(rs, null, executeCommand).then(function (res) {
            assert.strictEqual(res, result);
        });
    },
    'should call executeCommand with an existing file': function shouldCallExecuteCommandWithAnExistingFile(ctx) {
        var rs = fs.createReadStream(ctx.jpegFile);
        var tempFile = void 0;
        var fileCreated = false;
        var error = void 0;
        var executeCommand = function executeCommand(_tempFile) {
            tempFile = _tempFile;
            return assertExists(tempFile).then(function () {
                fileCreated = true;
            }, function (_error) {
                error = _error;
            });
        };
        return executeWithRs(rs, null, executeCommand).then(function () {
            assert(fileCreated);
            assert.equal(error, undefined);
        });
    },
    'should call executeCommand with args': function shouldCallExecuteCommandWithArgs(ctx) {
        var rs = fs.createReadStream(ctx.jpegFile);
        var testArgs = ['some-arg=value'];
        var args = void 0;
        var executeCommand = function executeCommand(_, _args) {
            args = _args;
        };
        return executeWithRs(rs, testArgs, executeCommand).then(function () {
            assert.strictEqual(args, testArgs);
        });
    },
    'should remove temp file': function shouldRemoveTempFile(ctx) {
        var rs = fs.createReadStream(ctx.jpegFile);
        var tempFile = void 0;
        var executeCommand = function executeCommand(_tempFile) {
            tempFile = _tempFile;
        };
        return executeWithRs(rs, null, executeCommand).then(function () {
            return assertDoesNotExist(tempFile);
        });
    },
    'should reject with execution error': function shouldRejectWithExecutionError(ctx) {
        ctx.create();
        var error = new Error('error during execution');
        return ctx.ep.open().then(function () {
            var rs = fs.createReadStream(ctx.jpegFile);
            var executeCommand = function executeCommand() {
                throw error;
            };
            return executeWithRs(rs, null, executeCommand);
        }).then(function () {
            throw new Error('should have thrown execution error');
        }, function (err) {
            assert.strictEqual(err, error);
        });
    },
    'should remove temp file if executeCommand failed': function shouldRemoveTempFileIfExecuteCommandFailed(ctx) {
        ctx.create();
        var error = new Error('error during execution');
        var tempFile = void 0;
        return ctx.ep.open().then(function () {
            var rs = fs.createReadStream(ctx.jpegFile);
            var executeCommand = function executeCommand(_tempFile) {
                tempFile = _tempFile;
                throw error;
            };
            return executeWithRs(rs, null, executeCommand);
        }).then(function () {
            throw new Error('should have thrown execution error');
        }, function () {
            return assertDoesNotExist(tempFile);
        });
    }
};

module.exports = {
    readFromStreamTestSuite: readFromStreamTestSuite,
    readFromRsTestSuite: readFromRsTestSuite
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3Qvc3BlYy9yZWFkLWZyb20tc3RyZWFtLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJjb250ZXh0IiwiZnMiLCJtYWtlcHJvbWlzZSIsImV4aWZ0b29sIiwiZXhlY3V0ZVdpdGhScyIsImdsb2JhbEV4aWZ0b29sQ29uc3RydWN0b3IiLCJFeGlmdG9vbFByb2Nlc3MiLCJyZWFkRnJvbVN0cmVhbVRlc3RTdWl0ZSIsImN0eCIsImNyZWF0ZSIsImVwIiwib3BlbiIsInRoZW4iLCJycyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJqcGVnRmlsZSIsInJlYWRNZXRhZGF0YSIsInJlcyIsIkFycmF5IiwiaXNBcnJheSIsImRhdGEiLCJsZW5ndGgiLCJhc3NlcnRKcGVnTWV0YWRhdGEiLCJhc3NlcnREb2VzTm90RXhpc3QiLCJmaWxlIiwic3RhdCIsIkVycm9yIiwiZXJyIiwidGVzdCIsIm1lc3NhZ2UiLCJhc3NlcnRFeGlzdHMiLCJyZWFkRnJvbVJzVGVzdFN1aXRlIiwiZXF1YWwiLCJleGVjdXRlQ29tbWFuZCIsIl9leGVjdXRlQ29tbWFuZCIsImJpbmQiLCJyZXN1bHQiLCJzb21lIiwic3RyaWN0RXF1YWwiLCJ0ZW1wRmlsZSIsImZpbGVDcmVhdGVkIiwiZXJyb3IiLCJfdGVtcEZpbGUiLCJfZXJyb3IiLCJ1bmRlZmluZWQiLCJ0ZXN0QXJncyIsImFyZ3MiLCJfIiwiX2FyZ3MiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBTUEsU0FBU0MsUUFBUSxRQUFSLENBQWY7QUFDQSxJQUFNQyxVQUFVRCxRQUFRLGtCQUFSLENBQWhCO0FBQ0EsSUFBTUUsS0FBS0YsUUFBUSxJQUFSLENBQVg7QUFDQSxJQUFNRyxjQUFjSCxRQUFRLGFBQVIsQ0FBcEI7QUFDQSxJQUFNSSxXQUFXSixRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFNSyxnQkFBZ0JMLFFBQVEsMkJBQVIsQ0FBdEI7O0FBRUFDLFFBQVFLLHlCQUFS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T0gsbUJBQW1CZ0IsUUFBbkIsQ0FBUDtBQUNILFNBYkUsQ0FBUDtBQWNIO0FBMUh1QixDQUE1Qjs7QUE2SEFVLE9BQU9DLE9BQVAsR0FBaUI7QUFDYjNDLG9EQURhO0FBRWJ3QjtBQUZhLENBQWpCIiwiZmlsZSI6InJlYWQtZnJvbS1zdHJlYW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgY29udGV4dCA9IHJlcXVpcmUoJ2V4aWZ0b29sLWNvbnRleHQnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBtYWtlcHJvbWlzZSA9IHJlcXVpcmUoJ21ha2Vwcm9taXNlJylcbmNvbnN0IGV4aWZ0b29sID0gcmVxdWlyZSgnLi4vLi4vc3JjLycpXG5jb25zdCBleGVjdXRlV2l0aFJzID0gcmVxdWlyZSgnLi4vLi4vc3JjL2V4ZWN1dGUtd2l0aC1ycycpXG5cbmNvbnRleHQuZ2xvYmFsRXhpZnRvb2xDb25zdHJ1Y3RvciA9IGV4aWZ0b29sLkV4aWZ0b29sUHJvY2Vzc1xuXG5jb25zdCByZWFkRnJvbVN0cmVhbVRlc3RTdWl0ZSA9IHtcbiAgICBjb250ZXh0LFxuICAgICdzaG91bGQgcmVhZCBtZXRhZGF0YSBmcm9tIGEgcmVhZCBzdHJlYW0nOiAoY3R4KSA9PiB7XG4gICAgICAgIGN0eC5jcmVhdGUoKVxuICAgICAgICByZXR1cm4gY3R4LmVwLm9wZW4oKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShjdHguanBlZ0ZpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5lcC5yZWFkTWV0YWRhdGEocnMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydCAoQXJyYXkuaXNBcnJheShyZXMuZGF0YSkpXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHJlcy5kYXRhLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5hc3NlcnRKcGVnTWV0YWRhdGEocmVzLmRhdGFbMF0pXG4gICAgICAgICAgICB9KVxuICAgIH0sXG59XG5cbmZ1bmN0aW9uIGFzc2VydERvZXNOb3RFeGlzdChmaWxlKSB7XG4gICAgcmV0dXJuIG1ha2Vwcm9taXNlKGZzLnN0YXQsIFtmaWxlXSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgaGF2ZSB0aHJvd24gRU5PRU5UIGVycm9yJylcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKCEvRU5PRU5ULy50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxufVxuZnVuY3Rpb24gYXNzZXJ0RXhpc3RzKGZpbGUpIHtcbiAgICByZXR1cm4gbWFrZXByb21pc2UoZnMuc3RhdCwgW2ZpbGVdKVxuICAgICAgICAudGhlbigoKSA9PiB7fSlcbn1cblxuY29uc3QgcmVhZEZyb21Sc1Rlc3RTdWl0ZSA9IHtcbiAgICBjb250ZXh0LFxuICAgICdzaG91bGQgcmVqZWN0IGlmIG5vbi1yZWFkYWJsZSBwYXNzZWQnOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBleGVjdXRlV2l0aFJzKCdzdHJpbmcnLCBudWxsLCAoKSA9PiB7fSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvcicpXG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGVyci5tZXNzYWdlLCAnUGxlYXNlIHBhc3MgYSByZWFkYWJsZSBzdHJlYW0nKVxuICAgICAgICAgICAgfSlcbiAgICB9LFxuICAgICdzaG91bGQgcmVqZWN0IGlmIGV4ZWN1dGVDb21tYW5kIGlzIG5vdCBhIGZ1bmN0aW9uJzogKGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oY3R4LmpwZWdGaWxlKVxuICAgICAgICByZXR1cm4gZXhlY3V0ZVdpdGhScyhycylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvcicpXG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGVyci5tZXNzYWdlLCAnZXhlY3V0ZUNvbW1hbmQgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICAgICAgICAgIH0pXG4gICAgfSxcbiAgICAnc2hvdWxkIHJlYWQgZnJvbSBhIHJzJzogKGN0eCkgPT4ge1xuICAgICAgICBjdHguY3JlYXRlKClcbiAgICAgICAgcmV0dXJuIGN0eC5lcC5vcGVuKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oY3R4LmpwZWdGaWxlKVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVDb21tYW5kID0gY3R4LmVwLl9leGVjdXRlQ29tbWFuZC5iaW5kKGN0eC5lcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVdpdGhScyhycywgbnVsbCwgZXhlY3V0ZUNvbW1hbmQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydCAoQXJyYXkuaXNBcnJheShyZXMuZGF0YSkpXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHJlcy5kYXRhLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5hc3NlcnRKcGVnTWV0YWRhdGEocmVzLmRhdGFbMF0pXG4gICAgICAgICAgICB9KVxuICAgIH0sXG4gICAgJ3Nob3VsZCByZXR1cm4gZXhlY3V0ZSBmdW5jdGlvbiByZXN1bHQnOiAoY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShjdHguanBlZ0ZpbGUpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt7IHNvbWU6ICdtZXRhZGF0YScgfSwgbnVsbF1cbiAgICAgICAgY29uc3QgZXhlY3V0ZUNvbW1hbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVXaXRoUnMocnMsIG51bGwsIGV4ZWN1dGVDb21tYW5kKVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChyZXMsIHJlc3VsdClcbiAgICAgICAgICAgIH0pXG4gICAgfSxcbiAgICAnc2hvdWxkIGNhbGwgZXhlY3V0ZUNvbW1hbmQgd2l0aCBhbiBleGlzdGluZyBmaWxlJzogKGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oY3R4LmpwZWdGaWxlKVxuICAgICAgICBsZXQgdGVtcEZpbGVcbiAgICAgICAgbGV0IGZpbGVDcmVhdGVkID0gZmFsc2VcbiAgICAgICAgbGV0IGVycm9yXG4gICAgICAgIGNvbnN0IGV4ZWN1dGVDb21tYW5kID0gKF90ZW1wRmlsZSkgPT4ge1xuICAgICAgICAgICAgdGVtcEZpbGUgPSBfdGVtcEZpbGVcbiAgICAgICAgICAgIHJldHVybiBhc3NlcnRFeGlzdHModGVtcEZpbGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaWxlQ3JlYXRlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9LCAoX2Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gX2Vycm9yXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhlY3V0ZVdpdGhScyhycywgbnVsbCwgZXhlY3V0ZUNvbW1hbmQpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpbGVDcmVhdGVkKVxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChlcnJvciwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgfSlcbiAgICB9LFxuICAgICdzaG91bGQgY2FsbCBleGVjdXRlQ29tbWFuZCB3aXRoIGFyZ3MnOiAoY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShjdHguanBlZ0ZpbGUpXG4gICAgICAgIGNvbnN0IHRlc3RBcmdzID0gWydzb21lLWFyZz12YWx1ZSddXG4gICAgICAgIGxldCBhcmdzXG4gICAgICAgIGNvbnN0IGV4ZWN1dGVDb21tYW5kID0gKF8sIF9hcmdzKSA9PiB7XG4gICAgICAgICAgICBhcmdzID0gX2FyZ3NcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhlY3V0ZVdpdGhScyhycywgdGVzdEFyZ3MsIGV4ZWN1dGVDb21tYW5kKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChhcmdzLCB0ZXN0QXJncylcbiAgICAgICAgICAgIH0pXG4gICAgfSxcbiAgICAnc2hvdWxkIHJlbW92ZSB0ZW1wIGZpbGUnOiAoY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShjdHguanBlZ0ZpbGUpXG4gICAgICAgIGxldCB0ZW1wRmlsZVxuICAgICAgICBjb25zdCBleGVjdXRlQ29tbWFuZCA9IChfdGVtcEZpbGUpID0+IHtcbiAgICAgICAgICAgIHRlbXBGaWxlID0gX3RlbXBGaWxlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVXaXRoUnMocnMsIG51bGwsIGV4ZWN1dGVDb21tYW5kKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnREb2VzTm90RXhpc3QodGVtcEZpbGUpXG4gICAgICAgICAgICB9KVxuICAgIH0sXG4gICAgJ3Nob3VsZCByZWplY3Qgd2l0aCBleGVjdXRpb24gZXJyb3InOiAoY3R4KSA9PiB7XG4gICAgICAgIGN0eC5jcmVhdGUoKVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignZXJyb3IgZHVyaW5nIGV4ZWN1dGlvbicpXG4gICAgICAgIHJldHVybiBjdHguZXAub3BlbigpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGN0eC5qcGVnRmlsZSlcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRlQ29tbWFuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVXaXRoUnMocnMsIG51bGwsIGV4ZWN1dGVDb21tYW5kKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBoYXZlIHRocm93biBleGVjdXRpb24gZXJyb3InKVxuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChlcnIsIGVycm9yKVxuICAgICAgICAgICAgfSlcbiAgICB9LFxuICAgICdzaG91bGQgcmVtb3ZlIHRlbXAgZmlsZSBpZiBleGVjdXRlQ29tbWFuZCBmYWlsZWQnOiAoY3R4KSA9PiB7XG4gICAgICAgIGN0eC5jcmVhdGUoKVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignZXJyb3IgZHVyaW5nIGV4ZWN1dGlvbicpXG4gICAgICAgIGxldCB0ZW1wRmlsZVxuICAgICAgICByZXR1cm4gY3R4LmVwLm9wZW4oKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShjdHguanBlZ0ZpbGUpXG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0ZUNvbW1hbmQgPSAoX3RlbXBGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBGaWxlID0gX3RlbXBGaWxlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlV2l0aFJzKHJzLCBudWxsLCBleGVjdXRlQ29tbWFuZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgaGF2ZSB0aHJvd24gZXhlY3V0aW9uIGVycm9yJylcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXJ0RG9lc05vdEV4aXN0KHRlbXBGaWxlKVxuICAgICAgICAgICAgfSlcbiAgICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZWFkRnJvbVN0cmVhbVRlc3RTdWl0ZSxcbiAgICByZWFkRnJvbVJzVGVzdFN1aXRlLFxufVxuIl19